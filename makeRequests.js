/**
 * Задача повышенной сложности. Её делать необязательно,
 * но она поможет лучше разобраться с тем, как работают
 * асинхронные запросы. Это задание будет довольно тщательно
 * проверено и по нему будет персональная обратная связь.
 * Делать по желанию и возможности.
 *
 * Напишите функцию makeRequests(urls, maxRequests), получающую
 * на вход массив ссылок urls и число maxRequests - максимальное
 * количество одновременных запросов. Запросы должны выполняться 
 * максимально быстрым образом. 
 * 
 * Пример: массив длинной 10, максимальное кол-во запросов 3.
 * Сразу делаете 3 запроса. Как только любой из них выполнился, 
 * сразу же начинать делать 4ый, а не дожидаетесь окончания двух других.
 * 
 * Условия:
 * 1. Одновременно должно выполняться не более указанного
 *    числа запросов.
 * 2. Должен возвращаться promise, резолвящийся в массив результатов
 *    в той же последовательности, что и адреса запросов.
 * 3. Представить, что все запросы успешно резолвятся и не обрабатывать
 *    ошибки.
 * 4. Если успешно справился с тремя пунктами, то реализовать такую логику:
 *    При падении любого из запросов вернувшийся промис
 *    должен реджектиться с той же ошибкой, что и оригинальный
 *    запрос.
 *
 * @param  {string[]} urls      массив с адресами
 * @param  {number} maxRequests максимальное количество одновременных запросов
 * @return {Promise}
 */

/*--------------------------------------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------------------------------------*/
/*
Описание функции:

Создаём массив, где будут содержаться промисы и переменную, где будет актуальное кол-во выполняемых запросов.
Далее начинаем перебирать ссылки.
Ставим цикл(максимальное число итераций составит 2), вторая итерация произойдёт, если число выполняемых запросов будет совпадать с максимальным числом.
Делаем проверку на максимальное число, если актуальное число меньше максимального, увеличиваем актуальное на 1 и деалем запрос через fetch().
fetch вернёт промис, который мы пушим в массив и через finally прописываем, что в случае окончания промиса(причём не важно, окончится он с ошибкой или нет)
он вычитает из актуального числа выпалняемых запросов 1, иначе ждем через Promise.race окончания хотя бы одного промиса и начианаем обрабатывать запрос.
Когда все ссылки были обработаны, ждём выполнения Promise.all, который будет ждать когда окончаться все промисы из массива и вернёт промис, 
в котором будет массив из результатов промисов.
*/
async function makeRequests(urls, maxRequests){
      
  let ArrPromises = []//массив промисов
  let countRequests=0//колличество обрабатываемых запросов

  // Итерация по ссылкам
  for (const url of urls) {
    

        let flg_load_promies=true

        while(flg_load_promies){  
          if (countRequests < maxRequests) {

            countRequests+=1;
            // Запускаем запрос
            let p=fetch(url)
            ArrPromises.push(p)
            p.finally(countRequests-=1)
            flg_load_promies=false
            
          } else {

              await Promise.race(ArrPromises)
            
          }
        }

    
  }

// Дожидаемся завершения всех запросов
 return Promise.all(ArrPromises).catch(error=> console.log(error.message))
}

// Список ссылок
const urls = [
    'https://jsonplaceholder.typicode.com/users',
    'https://jsonplaceholder.typicode.com/todos',
    'https://jsonplaceholder.typicode.com/photos',
    'https://jsonplaceholder.typicode.com/albums',
    'https://jsonplaceholder.typicode.com/comments',
    'https://jsonplaceholder.typicode.com/posts',
  ];


const x =makeRequests(urls, 3).then((values) => {
    console.log(values);
  });
